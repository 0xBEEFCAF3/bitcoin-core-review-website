---
layout: pr
date: 2023-10-04
title: "Type-safe transaction identifiers"
pr: 28107
authors: [dergoegge]
components: ["utils/log/libs"]
host: stickies-v
status: upcoming
commit: e74152d5b48bdca8dfc2217f35842dbb24b2746c
---

## Notes

- Since the activation of SegWit, transactions are identifiable by two types of identifiers: `txid` and `wtxid`. Both identifiers are a `uint256` resulting from a double `sha256` hash of serialized transaction data. The core [difference](https://github.com/bitcoin/bitcoin/blob/dcfbf3c2107c3cb9d343ebfa0eee78278dea8d66/src/primitives/transaction.h#L276-L280) is that `wtxid` includes the witness data, while `txid` does not.
 
- Type-safety is a concept in programming to help avoid type errors, enforcing strict correspondence between a variable and its type. It ensures that a program performs only legal operations on data, with validation occurring during compile-time. This proactive error detection and prevention lead to more reliable and maintainable software, minimizing unintended behavior and vulnerabilities. An example of an earlier type-safety improvement in Bitcoin Core is the incorporation of `std::chrono`, introduced in [#16908](https://github.com/bitcoin/bitcoin/pull/16908).

- In the context, of transaction identifiers, type-safety is important because it is impossible to deduce the type difference from just the `uint256` value. With `GenTxid` type checking can be done, but it is more verbose and done at run-time instead of at compile-time. Additionally, transaction identifier types improve readability of code by being explicit about expected types instead of solely relying on clear variable naming.

- This PR aims to improve type safety by introducing the new [`transaction_identifier`](https://github.com/bitcoin-core-review-club/bitcoin/commit/28f9ff3d5416407d3c6d5374f6fc3c2767f4a7f3#diff-f3d91988bf7d98529d638fa829dc3fab695be002305a7614eaaeb283d4fb8101R18) type, with `Txid` and `Wtxid` typedefs for brevity.

- There are instances where `wtxid` and `txid` are treated identically, such as for example in [`most_recent_block_txs`](https://github.com/bitcoin/bitcoin/blob/6619d6a8dca5a4d8e664a76526ac6bef3eb17831/src/net_processing.cpp#L1916-L1918), where the `uint256` type is used to handle this. In other contexts such as [`CTxMemPool::info`](https://github.com/bitcoin/bitcoin/blob/dcfbf3c2107c3cb9d343ebfa0eee78278dea8d66/src/txmempool.cpp#L862) where `wtxid` and `txid` are treated differently but either is accepted, the [`GenTxid`](https://github.com/bitcoin/bitcoin/blob/dcfbf3c2107c3cb9d343ebfa0eee78278dea8d66/src/primitives/transaction.h#L425) type is adopted.

## Questions

### Concept

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)? What was your review approach?

1. What does it mean for a transaction identifier to be type-safe? Why is that important or helpful? Are there any downsides?

1. Why is it better to enforce types at compile-time instead of at run-time?

1. Conceptually, when writing new code that requires referring to transactions, when should you use `txid` and when should you use `wtxid`? Can you point to any examples in the code where using one instead of the other could be very bad? (1 point per example)

1. In which concrete way(s) could using `transaction_identifier` instead of `uint256` help find existing bugs or prevent the introduction of new ones? On the other hand, could this change introduce new bugs?

1. SegWit activated at block height 481,824. Do transactions in blocks < 481,824 also have a `wtxid`? For example, what about transaction with `txid` `dc01120a639283c11eeada6ce540178adfbbca7fe0d2f41076367cbc9e901822`?

1. Are there any places where a (w)txid is returned as a `uint256` where it would not make sense to return a `transaction_identifier` instead?

1. The [`GenTxid`](https://github.com/bitcoin/bitcoin/blob/dcfbf3c2107c3cb9d343ebfa0eee78278dea8d66/src/primitives/transaction.h#L425) class already exists. How does it already enforce type correctness, and how is it different from the approach in this PR?

1. Are there any places where `GenTxid` is used but using `transaction_identifier` would be better?

### Code Review

{:start="10"}
1. How is `transaction_identifier` able to subclass `uint256`, given that, in C++, integers are types and not classes?

1. Why does `transaction_identifier` subclass `uint256` instead of being a completely new type?

1. `Txid` and `Wtxid` are typedefs for `transaction_identifier<has_witness>`. Do you see any reason for code to directly use the `transaction_identifier` type? Should that be forbidden, and if so, how?

1. [`transaction_identifier::Compare`](https://github.com/bitcoin-core-review-club/bitcoin/commit/28f9ff3d5416407d3c6d5374f6fc3c2767f4a7f3#diff-f3d91988bf7d98529d638fa829dc3fab695be002305a7614eaaeb283d4fb8101R39) is defined to return a `int`, yet `reinterpret_cast<const uint256&>` is used in the return statement. Is this correct, and if so, why? Why `reinterpret_cast` instead of another cast, such as `static_cast`?

1. Is the [`has_witness`](https://github.com/bitcoin-core-review-club/bitcoin/commit/28f9ff3d5416407d3c6d5374f6fc3c2767f4a7f3#diff-f3d91988bf7d98529d638fa829dc3fab695be002305a7614eaaeb283d4fb8101R17) template parameter used for purposes other than type differentiation in `transaction_identifier`? What are the limitations of this approach? Do you see alternatives?

1. Why is `TxOrphanage` a good place to start introducing type-safe transaction ids?

1. Consider [`return m_wtxid_to_orphan_it.count(Wtxid::FromUint256(gtxid.GetHash()));`](https://github.com/bitcoin-core-review-club/bitcoin/commit/e74152d5b48bdca8dfc2217f35842dbb24b2746c#diff-7cfa3d46c37a17d80c78a37d1239b572a03095d50879ba610d87b702cd844f9dR177). Why is it not type-safe to allow `Wtxid` to be constructed by just passing a `uint256` to its constructor? Specifically, why doesn't `Wtxid{gtxid.GetHash()}` compile?


## Meeting Log

### Meeting 1

{% irc %}
17:00 <stickies-v> #startmeeting
17:00 <dberkelmans> hi
17:00 <dergoegge> hi
17:00 <BrandonOdiwuor> Hello
17:01 <lightlike> hi
17:01 <larryruane_> hi
17:01 <vmammal> first timer here. im here to learn
17:01 <stickies-v> welcome everyone! Today we're looking at #28107, authored by dergoegge . The notes and questions are available on https://bitcoincore.reviews/28107
17:02 <stickies-v> great, glad you're joining us vmammal! any other first timers today?
17:02 <Murch[m]> Hey
17:02 <stickies-v> even if you're just lurking, feel free to say hi!
17:02 <sipa> hi
17:02 <larryruane_> will we be back here tomorrow? are we covering the first set of questions today (concept)?
17:03 <stickies-v> correct larryruane_ ! same time tomorrow for the second batch of questions
17:03 <glozow> hi
17:03 <effexzi> Hi every1
17:03 <maxedwards> hi
17:03 <stickies-v> who got the chance to review the PR or read the notes? (y/n)
17:03 <Murch[m]> n
17:03 <maxedwards> y
17:03 <BrandonOdiwuor> y
17:03 <lightlike> y
17:03 <dberkelmans62> y
17:03 <abubakarsadiq> hi
17:03 <glozow> woohooo welcome newcomers!
17:03 <glozow> y
17:04 <stickies-v> alright wonderful, let's dive into the wonderfully wholesome world of type-safety
17:05 <larryruane_> i heard someone say years ago, "strong types are for weak minds" (haha I don't agree!)
17:05 <stickies-v> for those of you who were able to review, would you give it a Concept ACK, Approach ACK, Tested ACK, or NACK? what was your review approach?
17:05 <vmammal> concept ACK
17:06 <larryruane_> i'm still reviewing
17:06 <maxedwards> Concept ACK
17:06 <BrandonOdiwuor> Concept ACK
17:06 <abubakarsadiq> Concept ACK, did not do code review but I think this is very useful improvement, not only that uint256 can be block hask, header, txid and wtxid. It will be nice to distinguish between wtxid and txid with type. Because there is ambiguity in the code whereby hash is referred to txid, wtxid and blockhash. Using type specifier for wtxid and txid will help distinguish even if an ambiguous variable name is used
17:07 <maxedwards> built and ran tests, read through the code, looked at the super class of uint256
17:07 <stickies-v> abubakarsadiq: I agree! compile-time checks (which we'll get to in a bit) are a great improvement on their own, but just improving code readability is quite nice too imo
17:08 <stickies-v> so, diving into the conceptual side of things a bit
17:08 <stickies-v> 2. What does it mean for a transaction identifier to be type-safe? Why is that important or helpful? Are there any downsides?
17:08 <larryruane_> before I approach ACK, I'm trying to figure out if it would be better for a `Txid` and a `Wtxid` to *inheret* from `uint256`, or for them to simply *include* a `uint256` (and nothing more, you could call this wrapping)
17:09 <BrandonOdiwuor> A 'transaction identifier' is considered 'type-safe' when it undergoes rigorous type-checking during compile-time, guaranteeing that operations involving these identifiers are thoroughly validated and constrained to their intended data types before the program is executed, thus preventing type-related errors and ensuring program reliability.
17:09 <BrandonOdiwuor> Some advantages include: Early detection of type-errors at compile time and preventing runtime errors
17:10 <larryruane_> type safe means the two kinds of transaction IDs have distinct types (instead of both being `uint256`), so trying to assign one type to a variable of another type (for example) is like trying to assign a `float` to an `int`
17:10 <stickies-v> larryruane_: I have had similar thoughts. I think inheritance makes the transition easier, i.e. if we don't want to update all places that use a transaction identifier
17:10 <stickies-v> but ignoring that it seems like just having a `uint256` member seems like it would simplify the implementation quite a bit
17:11 <larryruane_> @stickies-v thanks, that's my suspicion too, but wasn't sure, want to investigate further
17:12 <abubakarsadiq> there are two types of transaction identifiers in post segwit bitcoin, txid and wtxid. 
17:12 <abubakarsadiq> To avoid ambiguity and logic error where both are interchanged, it will be better if they are distinct types
17:12 <abubakarsadiq> The code won't compile if one is used in the place of another.
17:13 <larryruane_> a C codebase i worked on years ago had a really cool concept of "wrapped" integers, so you couldn't assign a block count (this was a storage system) to a byte count, etc. .... so similar goal as here, but it used the wrapped approach (since there's no inheretence in C)
17:13 <stickies-v> BrandonOdiwuor: would you say the error catching happens mostly at compile time or at runtime?
17:13 <maxedwards> can you elaborate on the simplicity enabled by having an internal uint256 vs subclassing?
17:13 <stickies-v> larryruane_: is type safety guaranteed by just having two distinct types, though?
17:14 <BrandonOdiwuor94> stickies-v it would be better to catch the errors at compile-time rather than do runtime assertions to catch the errors
17:14 <larryruane_> no, a block count type was a C struct with just one member, conventionally called `i` (for `integer`), and the byte count was a different C struct (also with just `i`) ... so you couldn't assign one to the other for example
17:15 <maxedwards> simply providing the types is not enough, they have to be consumed
17:15 <Murch[m]> I assume that with inheritance assignments might permit to autoconvert between the types without complaining
17:15 <stickies-v> BrandonOdiwuor94:  yeah, catching stuff at compile time is great - makes it quick for the developer to spot their error as they are developing, as opposed to relying on writing extensive test suites etc (that still may miss things) to catch things in runtime
17:15 <larryruane_> i.e. so it wasn't just two typedefs (which does NOT give type safety)
17:16 <stickies-v> larryruane_: i don't just mean typedefs: in a naive implementation, just having Txid and Wtxid each subclass uint256 does not provide type safety on its own, as e.g. we can still do comparisons between them
17:16 <larryruane_> yeah trying to catch things are runtime is tricky, you might never happen to go through the buggy code path! (but for sure one of our users will!)
17:17 <stickies-v> well, it does provide some type safety, just not entirely
17:17 <stickies-v> Murch[m]: yes exactly@
17:17 <maxedwards> Murch[m]: I believe there is a comment about doing just that in the PR
17:18 <stickies-v> maxedwards:  so the complexity that I was talking about is that currently we have to specify which kinds of comparisons etc we allow, because currently both `Txid` and `Wtxid` inherit from `uint256`
17:19 <stickies-v> I guess we already largely covered the next question but I'll throw it in here regardless in case anyone has something to add:
17:19 <larryruane_> to me, with my not-great understanding of subclassing, the wrapping approach seems simpler and safer -- two classes both with just one member, a `uint256` (like we did with the wrapped integers in C) ... but never mind, we can move on, sorry to distrupt
17:19 <stickies-v> 3. Why is it better to enforce types at compile-time instead of at run-time?
17:19 <glozow> find bug moar fast.
17:19 <BrandonOdiwuor> Early Error Detection: Compile-time checking allows for the identification of type-related errors and mismatches at compile time before the program is even executed. This means that issues are caught during the development and testing phase, reducing the chances of runtime errors and unexpected program behavior.
17:20 <larryruane_> stickies-v: kind of answered already, but it prevents coding mistakes where the wrong kind of ID is used (txid instead of wtxid or the reverse)
17:20 <stickies-v> larryruane_: but with wrapping, would you still be able to not update all callsites of functions that return a Txid/Wtxid right away?
17:20 <stickies-v> I think there's merit to allowing this to be a gradual improvement
17:20 <stickies-v> glozow: much accurate
17:20 <larryruane_> @stickies-v yes very true! that's an important consideration
17:21 <stickies-v> BrandonOdiwuor: yeah it's generally much quicker
17:22 <BrandonOdiwuor> I saw this comment on the notes (https://github.com/bitcoin/bitcoin/pull/28031#discussion_r1261648754) I think it would help with this
17:23 <glozow> yeah I write this bug approximately once every 2 weeks
17:23 <maxedwards> assuming less than perfect test coverage and a bug, a runtime check could end up throwing on production
17:23 <maxedwards> worst case and I'm sure with the scrutiny of bitcoin it would be caught in an earlier stage
17:24 <glozow> Usually I catch it before I push a PR tho. always need to have a "try 2 transactions with same txid but diff witness" test
17:24 <glozow> catching at compile time would be nice
17:25 <stickies-v> maxedwards: even if it can be tested, being able to remove tests because it's checked at compile time is a big win
17:25 <abubakarsadiq> glozow: with this you dont have to do that right \o/?
17:25 <stickies-v> launching the next question already - but as always, feel free to continue the conversation on previous questions too!
17:25 <stickies-v> 4. Conceptually, when writing new code that requires referring to transactions, when should you use `txid` and when should you use `wtxid`? Can you point to any examples in the code where using one instead of the other could be very bad? (1 point per example)
17:26 <lightlike> seems like testing this would still be useful.  having type safety won't prevent us from using the wrong type of id (but consistently) in the first place.
17:27 <larryruane_> stickies-v: not sure if this is what you're asking, but two pure segwit transactions with the same txid (even if different wtxids) have the same *effect* (modify the UTXO set the same way)
17:27 <larryruane_> lightlike: +1
17:27 <glozow> lightlike +1
17:28 <larryruane_> (pure meaning *all* the inputs are segwit)
17:28 <glozow> this is a good example imo: https://github.com/bitcoin/bitcoin/blob/3cd02806ecd2edd08236ede554f1685866625757/src/net_processing.cpp#L4334
17:28 <sipa> larryruane_: two non-segwit transactions with the same txid also have the same effect :p
17:28 <glozow> if you use txid, that means I can censor any tx I want to you by sending you a version with a mutated witness first
17:29 <stickies-v> glozow: 1 point!
17:30 <larryruane_> sipa: oh right... two tx with different txids could have the same effect (i think??)
17:30 <larryruane_> (that's malleability)
17:30 <sipa> larryruane_: yes
17:30 <sipa> the same txid implies the same effect, but different txid does not imply different effect
17:31 <lightlike> so "when in doubt use wtxid" is a good role of thumb i guess?
17:31 <stickies-v> so even if you haven't found any examples, conceptually - what do you think is a good heuristic for when to use wtxid instead of txid, or txid instead of wtxid?
17:32 <stickies-v> lightlike: that seems a reasonable starting point :-D 
17:33 <glozow> pretty much always wtxid unless it's prevout-related
17:33 <sipa> or tx relay for pre-BIP339 peers
17:33 <larryruane_> stickies-v: in the mempool, we definitely want to use txids as keys, because if we used wtxid, two tx with the same txid could be there simultaneously, and if that happened, an output from both of them could be spent separately, leading to double-spend bug?
17:34 <stickies-v> glozow: yeah, and also almost always wtxid when it's about unconfirmed txs?
17:35 <larryruane_> stickies-v: that sounds opposite to what i said? (but i may be wrong)
17:36 <abubakarsadiq> we could have identical transaction with multiple wtxid's using wtxid almost everytime, will that not bring duplication especially for unconfirmed txs?
17:36 <stickies-v> larryruane_: well i think gloria covered that already by it being prevout related?
17:36 <sipa> the mempool is indexed by both txid and wtxid, because we need to be able to look up by both
17:36 <glozow> unsure if unconfirmed txs are special. But one distinction that springs to mind is you should never try to cache feerate to a txid
17:37 <glozow> I think larryruane's point might be that having an index by txid can be a useful way to bake in the assumption that no 2 transactions in the data structure should have the same txid
17:37 <larryruane_> sipa: gotcha, but we definitely don't want to allow > 1 tx with the same txid
17:38 <maxedwards> am I right in thinking that in theory this same/different effect shouldn't be a concern for this PR as the existing code should already be using the correct id, it's just that it's represented by the same type?
17:39 <lightlike> larryruane: we don't want conflicting transactions in general, even if they don't share the txid.
17:39 <sipa> my guess is actually that if we dropped the unicity of the txid index in the mempool, nothing would break, as different-wtxid-same-txid transactions would still just conflict with each other
17:39 <sipa> the unicity just allows enforcing that constraint independently
17:39 <sipa> uniqueness? unicity?
17:40 <stickies-v> maxedwards: this is more conceptual discussion about txid/wtxid indeed and not directly critical for the PR
17:40 <larryruane_> lightlike: oh yes that's right, as glozow said, the prevout is txid-based so would be the same
17:40 <sipa> (tangent, english stackexchange says "I suspect most people would take "Unicity" to be a town where everyone rides unicycles.")
17:40 <maxedwards> stickies-v: very interesting still
17:41 <larryruane_> i took bicycle riding lessons but ran out of money halfway through, so now i can only ride a unicycle
17:41 <glozow> sipa: tbh I would have thought of it as the british equivalent of "college town"
17:41 <glozow> larryruane: are there 100 seats on 100 unicycles...
17:42 <sipa> :D
17:42 <stickies-v> alright time to move on 😅
17:42 <sipa> glozow: and they ride one by one into a room with 100 boxes, ...
17:42 <stickies-v> 5. In which concrete way(s) could using `transaction_identifier` instead of `uint256` help find existing bugs or prevent the introduction of new ones? On the other hand, could this change introduce new bugs?
17:42 <glozow> 😂
17:43 <larryruane_> stickies-v: is it because lots of other things besides txids and wtxids can be uint256 type? so using `transaction_identifier` would exclude those accidental uses?
17:45 <BrandonOdiwuor88> larryruane_ I think it would help prevent mixing up using Txid and Wtxid unintentionally such as the comment that was linked in the notes(https://github.com/bitcoin/bitcoin/pull/28031#discussion_r1261648754)
17:45 <stickies-v> larryruane_: yup. a function that takes a `uint256 hash` as an argument can specify in the docs that `hash` is supposed to be a wtxid, but if a developer (and the reviewers) don't read that properly then it's trivial to pass a txid and potentially (probably) break things
17:46 <glozow> fun anecdote related to this: one time while working in wallet code, I saw a variable named `wtxid` and assumed it was a witness ID. nope, it stood for "wallet transaction id"
17:47 <stickies-v> on the other hand - does having this explicit type potentially introduce other, new bugs? can you think of any?
17:47 <stickies-v> glozow: oooh yeah those are sneaky
17:47 <maxedwards> can you pass a uint256 to a function that asks for a txid?
17:47 <maxedwards> or do you have to cast?
17:47 <larryruane_> i just noticed that there are 1687 occurrences of `uint256` in our code base -- many (maybe most) of which are not transaction ID related!
17:49 <dergoegge> maxedwards: you would have to use `Txid::FromUint256`
17:49 <glozow> maxedwards: try and see if it compiles!
17:50 <stickies-v> maxedwards: see also question 16 that we'll be dealing with tomorrow!
17:50 <lightlike> dergoegge: did you try to change it everywhere, just to see how big the effort is?
17:50 <maxedwards> even with this, would it not be possible to change a parameter to a txid when it should be a wtxid and everything would still work?
17:50 <maxedwards> the uint256 was representing a wtxid
17:51 <maxedwards> but the type isn't actually enforcing that it is
17:51 <maxedwards> and could lead to much confusion
17:51 <maxedwards> even more confusion than had it been left as a uint256
17:51 <BrandonOdiwuor88> maxedwards I think the compiler would throw an error you have to cast explicitly with reinterpret_cast
17:51 <maxedwards> yes so I'm assuming you do cast
17:52 <stickies-v> maxedwards: what do you mean with change a parameter? the function signature?
17:52 <maxedwards> but there's nothing stopping you from casting a uint256 that represented a wtxid to a txid is there?
17:52 <maxedwards> yes function signature
17:52 <stickies-v> well obviously the function signature has to be correct, if you need a wtxid and have your function signature take a `Txid txid` then that's going to lead to problems
17:53 <maxedwards> not compile time problems though is my question
17:53 <dergoegge> lightlike: no haven't tried, my guess would be that it is a bunch of effort but also not to crazy
17:54 <stickies-v> it depends on the callsites of course. sorry i'm not sure i fully understand your question - type-safety doesn't prevent a developer from writing wrong code, indeed
17:55 <vmammal> dergoegge do you plan to continue the refactor in a future PR?
17:55 <dergoegge> `Txid::FromUint256(Wtxid{})` might actually work because `uint256 a = Wtxid{}` is allowed.
17:55 <stickies-v> gonna skip a few questions as we're running out of time
17:55 <dergoegge> vmammal: yes but I'd also be happy to see other people going for it
17:55 <stickies-v> 8. The `GenTxid` class already exists. How does it already enforce type correctness, and how is it different from the approach in this PR?
17:55 <stickies-v> (link: https://github.com/bitcoin/bitcoin/blob/dcfbf3c2107c3cb9d343ebfa0eee78278dea8d66/src/primitives/transaction.h#L425) 
17:58 <dberkelmans> It also contains a bool saying if the witness is included
17:58 <dberkelmans> It's one type instead of 2
17:58 <dberkelmans> So it doesn't make the code more readable
17:59 <larryruane_> for one thing, an instance of a txid and a wtxid (contained within a GenTxid) compare as false, even if the hashes are true ... but there's more I'm sure
17:59 <stickies-v> dberkelmans: if it doesn't make the code more readable, should we then replace it entirely with transaction_identifier?
18:00 <BrandonOdiwuor88> I think GenTxid uses uint256 to store the hash and the bool m_is_wtxid to indicate whether its Wtxid or Txid
18:00 <dberkelmans> I haven't seen enough code to say anything sensible about that
18:01 <stickies-v> I think an important difference is that GenTxid allows type checking, by exposing the `IsWtxid()` function, but it's still on the user to do that checking
18:01 <stickies-v> and more importantly, it happens at runtime
18:01 <dberkelmans> I suppose if you only need the uint256 then having it in one type makes sense
18:02 <larryruane_> stickies-v: so it's runtime checking rather than compile-time
18:02 <stickies-v> with transaction_identifer, the type checking is enforced at compile time
18:02 <stickies-v> larryruane_: yeah
18:02 <stickies-v> dberkelmans: well one important use case that GenTxid solves is that in quite a few places we want to be able to take input that can be either a txid or a wtxid, as opposed to just one or the other
18:03 <dergoegge> If we go for the type safe ids, my thinking was that we would replace `GenTxid` with `std::variant<Txid, Wtxid>`
18:03 <stickies-v> actually, from my quick skimming it seems like *all* the places where we use GenTxid we want to be able to accept both types (which surprised me a little)
18:03 <stickies-v> so, we're at time for this meeting
18:03 <stickies-v> #endmeeting
<!-- TODO: For additional meetings, add the logs to the same irc block. This ensures line numbers keep increasing, avoiding hyperlink conflicts for identical line numbers across meetings.
### Meeting 2

-->
{% endirc %}
