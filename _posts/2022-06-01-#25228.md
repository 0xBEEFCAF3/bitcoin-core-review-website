---
layout: pr
date: 2022-06-01
title: "Add BIP-125 rule 5 testcase with default mempool"
pr: 25228
authors: [jamesob]
components: ["tests"]
host: glozow
status: upcoming
commit:
---

## Notes

- Mempool validation enforces [ancestor and descendant count
  limits](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-limits.md#definitions),
requiring that no mempool transaction have more than 24 (25 with CPFP carve out) descendants.

- When a node receives a transaction that conflicts with, or spends the same prevout
  as, one or more of the transactions in its mempool, it decides which transaction(s) to keep based
on a set of rules. Bitcoin Core's Replace by Fee
[policy](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy)
requires that no transaction replace more than 100 mempool transactions ("Rule 5").

- Many people conclude that the descendant limit makes Rule 5 redundant; it seems that a transaction
  cannot replace more than 100 transactions a conflicting mempool transaction cannot have more than
25 descendants. This is a very common misconception.  A transaction can spend multiple prevouts, and
thus conflict with multiple unrelated transactions.


## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. What does it mean for a transaction to "conflict with" transactions in the mempool? What is the
   difference between a "directly" and "indirectly conflicting" transaction?

1. Based on the default RBF policy, how many "direct" conflicts is a transaction allowed to have?
   How many transactions is it allowed to replace?

1. Why should the node limit the number of transactions that can be replaced at a time? Can you
   think of any potential attacks

1. How is it possible for a transaction to conflict with 100 transactions if the descendant limit is
   25? Can you come up with an example that isn't the one tested in this PR?

1. What's wrong with configuring `-acceptnonstdtxn=1`, `-limitancestorcount`, `-limitancestorsize`,
   `-limitdescendantcount`, and `-limitdescendantsize`, to test mempool policy?

1. Why is it necessary to pass a different `sequence` to `create_self_transfer_multi`?

1. What does annotating `get_utxo` with the `-> dict` return type annotation do?


**Bonus Questions**

1. Rule 5 only restricts the number of transactions that can be replaced, not the size. However, an
effective maximum exists; what is the effective maximum virtual size of transactions that can be
replaced in a default mempool? (Hint: default [maximum transaction
weight](https://github.com/bitcoin/bitcoin/blob/b9ef5a10e2fa4609d048db57b99463305455ebe4/src/policy/policy.h#L24)
and [maximum ancestor/descendant
limits](https://github.com/bitcoin/bitcoin/blob/b9ef5a10e2fa4609d048db57b99463305455ebe4/src/validation.h#L64-L70)
(Hint Hint: not all of these numbers are relevant)).

1. Hypothetically, if we increased the default ancestor/descendant limits to 120, would we also need
   to change the limit on replaced transactions? (Hint: how can a transaction recipient prevent its
replacement?)

1. In what scenarios will the
   [code](https://github.com/bitcoin/bitcoin/blob/b9ef5a10e2fa4609d048db57b99463305455ebe4/src/policy/rbf.cpp#L60-L63)
for calculating the number of to-be-replaced transactions overestimate? If we call
`pool.CalculateDescendants()` with a set of 99 mempool entries, what is the maximum number of
mempool transactions we might traverse before the function returns?

<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
