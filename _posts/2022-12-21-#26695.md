---
layout: pr
date: 2022-12-21
title: "bench BlockAssembler on a mempool with packages"
pr: 26695
authors: [glozow]
components: ["bench"]
host: glozow
status: upcoming
commit: b053472
---

## Notes

- The
  [`BlockAssembler`](https://github.com/bitcoin/bitcoin/blob/aeb395dcdbfe2b1a6c77ff218939a18afde3add9/src/node/miner.h#L164)
is responsible for constructing a *block template* on top of the current chain tip. `CreateNewBlock`
selects transactions from the node's mempool to maximize fees and constructs the coinbase
transaction based on a scriptPubKey passed in. As the last step, it calls `TestBlockValidity()` to
verify that this block would be consensus-valid (apart from the missing proof of work).

- Miners may use the `getblocktemplate` RPC to retrieve a block template, utilize external hardware
  to compute the proof of work, and then publish their block using the `submitblock` RPC.

- The algorithm takes into account transaction ancestors and descendants in order to
  estimate the incentive compatibility of including or excluding some set of transactions in the
block template. We have discussed the implementation of this algorithm in a [previous review club
meeting](/24538).

- Bitcoin Core has a [benchmarking
  framework](https://github.com/bitcoin/bitcoin/blob/master/doc/benchmarking.md) to measure the
performance of various tasks such as adding to and clearing a `CRollingBloomFilter`, accessing a
`CCoinsCache`, deserializing and checking a block, and checking a mempool with complex contents.

- Bitcoin Core is multi-threaded. Some operations require holding one or more mutexes, which means
  [deadlock](https://en.wikipedia.org/wiki/Deadlock) is a potential concern. One method of avoiding
deadlock is to enforce a consistent order in which every thread acquires locks. Compile with
`-DDEBUG_LOCKORDER` to help find instances in which locks are grabbed in inconsistent orders.

## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. Why might we care about the performance of `BlockAssembler::CreateNewBlock()`?

1. Examining the
   [implementation](https://github.com/bitcoin/bitcoin/blob/7386da7a0b08cd2df8ba88dae1fab9d36424b15c/src/node/miner.cpp#L106)
of `CreateNewBlock()`, which tasks do you expect take the most time?

1. There are two `BlockAssembler` constructors: with and without the `Options` parameter. Given
   references to the active chainstate and mempool, `chainstate` and `mempool` respectively, what would
be the difference between calling `BlockAssembler(chainstate, mempool)` and
`BlockAssembler(chainstate, mempool, Options())`?

1. Given that block assembly time depends on what transactions there are in the mempool, is it a
   problem that `PopulateMempool()` randomly determines the transaction fees?

1. Commit
   [`5021832`](https://github.com/bitcoin-core-review-club/bitcoin/commit/50218324dac18556d87688dc1a8e89bbe4d5f69e)
changes the order in which `PopulateMempool()` grabs two locks. Why is this necessary?

1. Can you think of other mempool-related activities or scenarios worth benchmarking?

<!-- ## Meeting Log -->

<!-- {% irc %} -->
<!-- {% endirc %} -->
