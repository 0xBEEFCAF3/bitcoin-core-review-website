---
layout: pr
date: 2022-11-23
title: "Bump unconfirmed ancestor transactions to target feerate"
pr: 26152
authors: [Xekyo]
components: ["wallet"]
host: glozow
status: upcoming
commit: 898ad9d590
---

## Notes

- The wallet *funds* a transaction by selecting inputs to cover its payment amount(s) and the fee
  at the user's target feerate. This process is known as **coin selection**, which we have discussed in
previous review clubs [#22009](/22009), [#17526](/17526) and [#17331](/17331).

    - Notably, each candidate coin is considered using an "effective value," introduced in
      [PR #17331](https://github.com/bitcoin/bitcoin/pull/17331). This deducts the cost to spend
      this input at the target feerate from its `nValue`.

- Since [PR #7600](https://github.com/bitcoin/bitcoin/pull/7600), the
  [`BlockAssembler`](https://github.com/bitcoin/bitcoin/blob/aeb395dcdbfe2b1a6c77ff218939a18afde3add9/src/node/miner.h#L164)
algorithm has used ancestor feerate, rather than individual feerate, to select transactions for
inclusion in blocks. This strategy also enables users to fee-bump transactions using [Child Pays for
Parent (CPFP)](https://bitcoinops.org/en/topics/cpfp/). We have discussed the `BlockAssembler`
implementation in a [previous review club meeting](/24538).

- On the flip side of CPFP, a transaction's "effective" feerate depends on the UTXOs used to fund
  it: if unconfirmed UTXOs are used, since the transaction cannot be mined without its ancestors,
its "effective" feerate may decrease. Even while not trying to boost an unconfirmed transaction
using CPFP, if the wallet funds a transaction using unconfirmed UTXOs with feerates lower than the
target feerate, it may underestimate the amount of fees to put on this transaction. This issue has
been an open problem for years; see
[#9645](https://github.com/bitcoin/bitcoin/issues/9645),
[#9864](https://github.com/bitcoin/bitcoin/issues/9864), and
[#15553](https://github.com/bitcoin/bitcoin/issues/15553).

- Goal: when funding a transaction using unconfirmed inputs, in addition to funding the payment(s)
  and this transaction's fee, also include the fees necessary to bump those unconfirmed transactions
to the target feerate.

- One naive solution would be to select all the inputs, and then calculate the cost of bumping
  unconfirmed ancestors and add that to the fees. However, if the selected inputs cannot cover the
cost of ancestor fees, the selection process needs to be repeated; this strategy would (re)introduce
a looped coin selection algorithm and make changeless solutions much less common.

- Consider another solution which updates the "effective value" of a coin, reducing it by the fee
  necessary to bump its ancestor set to the target feerate: `effective_value = nValue -
cost_to_spend - min(0, target_feerate * ancestor_size - ancestor_fees)`. For example, if the target
feerate is 20sat/vB, the UTXO has type P2WPKH and value 100ksat, and transaction's ancestor fee and
vsize are 1200sat and 600vB respectively, the coin's effective value would be 100000sat -
(20sat/vB * 68vB) - (20sat/vB * 600vB - 1200sat) = 87840sat.

- However, this problem is much more complicated than simply using the ancestor size and fees of
  unconfirmed UTXOs:

    - Multiple UTXOs may come from the same transaction or share the same ancestry. We don't need to
      bump those transactions more than once.

    - An ancestor's feerate may be higher than the target feerate.

    - An ancestor may have a low feerate, but be already fee-bumped by another transaction in the
      mempool.

    - If the transaction replaces existing transactions in the mempool, one or multiple transactions
      may be evicted. After these evictions, some transactions may now need bumping, and others may
      no longer need bumping. For example, we may be replacing a previous CPFP child with an
      even higher feerate child.

- [PR #26152](https://github.com/bitcoin/bitcoin/pull/26152) adds `MiniMiner`, a "mini" version of
  the block assembly algorithm designed to calculate the cost to bump an unconfirmed UTXO to a
target feerate.  It uses `MiniMiner` to include the fees to bump any unconfirmed ancestors when
funding a transaction.

- `MiniMiner` operates on a limited set of mempool entries rather than the entire mempool, and does not care
about consensus rules such as block size and sigop limits. The limited set includes the "clusters"
of each unconfirmed transaction from which the wallet might spend a UTXO from. A *cluster* includes
all mempool entries "connected" to a transaction. This includes parents and children,
ancestors and descendants, as well as "siblings" (a transaction that shares a parent) and
"coparents," (a transaction that shares a child), etc.

- The PR adds a `CTxMemPool::CalculateCluster` function to calculate a set of transactions'
  clusters. It uses the epoch-based traversal strategy described in
[PR #17268](https://github.com/bitcoin/bitcoin/pull/17268) and first introduced in
[PR #17925](https://github.com/bitcoin/bitcoin/pull/17925).

- `MiniMiner` provides two functions: `CalculateBumpFees()` provides the bump fee for each UTXO
  independently, ignoring any cases where there are shared ancestries. This function is intended for
calculating effective values in `AvailableCoins`, when it is unknown exactly which coins might be
spent.  `CalculateTotalBumpFees()` provides the bump fee for a set of UTXOs to be spent together,
taking into consideration when UTXOs have shared ancestry. It is intended for calculating the final
fee to put on the transaction.

## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. What issue does this PR solve?

1. In
   [`CalculateCluster`](https://github.com/bitcoin-core-review-club/bitcoin/commit/995107782a1a512811d54f7abf29249f351a7cbf#diff-c065d4cd2398ad0dbcef393c5dfc53f465bf44723348892395fffd2fb3bac522R1218),
what does a transaction's "cluster" consist of?

1. Why does the `MiniMiner` require an entire cluster? Why can't it just use the union of each
   transaction's ancestor sets?

1. We know that a transaction's individual feerate is not necessarily indicative of how a miner will
  prioritize it. That is, if transaction X and Y have feerates fX and fY, fX > fY doesn't
necessarily imply that X will be selected sooner than Y. If two independent mempool transactions X
and Y have *ancestor feerates* gX and gY where gX > gY, which of the following are possible? (Here,
"independent" means that their respective clusters have no overlapping transactions).

    - a. X is selected sooner than Y
    - b. X is selected later than Y

1. The `MiniMiner`
   [constructor](https://github.com/bitcoin-core-review-club/bitcoin/blob/b669fd94f84e679d4549ef0abe1b0483e1406152/src/node/mini_miner.h#L94)
accepts a mempool reference and a list of outpoints the wallet might be interested in spending.
Given an outpoint, it may be one of four possible types:

    - a confirmed UTXO
    - a UTXO created by a mempool transaction and has not been spent yet
    - a UTXO created by a mempool transaction and has already been spent by another mempool
      transaction
    - a UTXO that does not exist in mempool or chainstate (perhaps not yet submitted to mempool)

   How does the `MiniMiner` constructor detect and handle each case?

1. `MiniMiner` builds a `descendant_set_by_txid` cache, but not an `ancestor_set_by_txid` cache.
   Instead, it
[calculates](https://github.com/bitcoin-core-review-club/bitcoin/blob/b669fd94f84e679d4549ef0abe1b0483e1406152/src/node/mini_miner.cpp#L145-L161)
ancestor sets on the fly. Do you think this approach makes sense? Why or why not?

1. At a high level, describe how
   [`MiniMiner::CalculateBumpFees()`](https://github.com/bitcoin-core-review-club/bitcoin/blob/898ad9d5904f1b689d18d94f20d92500cf443758/src/node/mini_miner.cpp#L186) works. Why can't we just use the ancestor feerate of each transaction?

1. Can `CalculateBumpFees()` overestimate, underestimate, both, or neither? By how much?

1. What are the similarities and differences in implementation between
   [`CalculateBumpFees`](https://github.com/bitcoin-core-review-club/bitcoin/blob/898ad9d5904f1b689d18d94f20d92500cf443758/src/node/mini_miner.cpp#L186) and
   [`CalculateTotalBumpFees`](https://github.com/bitcoin-core-review-club/bitcoin/blob/898ad9d5904f1b689d18d94f20d92500cf443758/src/node/mini_miner.cpp#L222)?

1. One potential approach for constructing the block is to define a custom ancestor score comparator
   for `MockMempoolEntry` (or even just reuse
[`CompareTxMemPoolEntryByAncestorFee`](https://github.com/bitcoin/bitcoin/blob/aeb395dcdbfe2b1a6c77ff218939a18afde3add9/src/txmempool.h#L277) from txmempool like the `BlockAssembler`
[does](https://github.com/bitcoin/bitcoin/blob/aeb395dcdbfe2b1a6c77ff218939a18afde3add9/src/node/miner.cpp#L347)),
and then iterate through a list of entries sorted by ancestor score. Why would this approach work for
`BlockAssembler` but not for `MiniMiner`?

1. This functionality is only used by the wallet. Instead of adding `CalculateBumpFees` to the [chain
   interface](https://github.com/bitcoin/bitcoin/pull/26152/commits/8b8bf19951c5877bd39a02a3e39ce246fadd3678),
should we just add it as a utility function in the wallet?

1. Describe the approach taken in the "Bump unconfirmed parent txs to target feerate"
   [commit](https://github.com/bitcoin/bitcoin/pull/26152/commits/ad8bffe548a2536f925e6911c7d50c1aaab1a59e).

1. What test cases are included in wallet\_spend\_unconfirmed.py added in the same
   [commit](https://github.com/bitcoin/bitcoin/pull/26152/commits/ad8bffe548a2536f925e6911c7d50c1aaab1a59e)?
Can you think of any other test cases to add?

1. Two coin selection results may require different fees for bumping ancestors. How does
   the wallet choose which one to use? (Hint: can you identify how bump fees come into play in
[`GetSelectionWaste()`](https://github.com/bitcoin-core-review-club/bitcoin/blob/898ad9d5904f1b689d18d94f20d92500cf443758/src/wallet/coinselection.cpp#L372))?

1. How does the PR handle spending unconfirmed UTXOs with overlapping ancestry? (Hint: what does the code
   [here](https://github.com/bitcoin-core-review-club/bitcoin/blob/898ad9d5904f1b689d18d94f20d92500cf443758/src/wallet/spend.cpp#L584) do)?


<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
