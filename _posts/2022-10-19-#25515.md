---
layout: pr
date: 2022-10-19
title: "Virtualise CConnman and add initial PeerManager unit tests"
pr: 25515
authors: [dergoegge]
components: ["p2p", "tests"]
host: larryruane
status: upcoming
commit: f98a4e8d89
---

## Notes

- [PR 25515](https://github.com/bitcoin/bitcoin/pull/25515) is a refactoring
  change that allows unit-testing of the
  [`PeerManager`](https://github.com/bitcoin/bitcoin/blob/a52ff619a45c760f657413cbd40e1e2226068541/src/net_processing.h#L41)
  class, by making `CConnman` mockable. `CConnman` is made mockable by defining
  an abstract interface class, `ConnectionsInterface`, that `CConnman` then
  inherits from.

- Currently, `PeerManager` holds a reference to `CConnman`
  ([`PeerManagerImpl::m_connman`](https://github.com/bitcoin-core-review-club/bitcoin/commit/9efcd9668d143afa2e8213a7bacf94da7f645e4c#diff-6875de769e90cec84d2e8a9c1b962cdbcda44d870d42e4215827e599e11e90e3R704))
  and the PR changes the type of that reference to `ConnectionsInterface`.
  Additionally, when a `PeerManager` instance is created, we now pass a
  `ConnectionsInterface` instead of a `CConnman`. With that, any unit tests can
  create a mocked version of the connection manager to test the internals of
  `PeerManager`.

- To demonstrate the added benefit, the PR also adds two initial `PeerManager`
  unit tests for the `version` and `ping/pong` messages (see
  [`peerman_tests.cpp`](https://github.com/dergoegge/bitcoin/blob/2022-06-virt-connman/src/test/peerman_tests.cpp)).

- `PeerManager` is currently almost exclusivly tested through our functional
  tests (See the `test/functional/p2p_*.py` tests). These tests spin up entire
  nodes and test functionality through the interfaces that nodes provide (p2p,
  rpc, rest, etc.).

## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or
   NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. Why do we need unit tests? Aren't functional tests sufficient?

1. Why do we need to mock `CConnman` to unit test `PeerManager`?

1. Do mock interfaces need to implement all of the real interfaces?

1. Should we mock other components as well? (e.g.: `CTxMempool`,
   `ChainstateManager`)

1. Roughly, what is the overhead of using an interface class?

1. How can you tell that a class is an interface class?

1. What do the `= 0` indicate at the definition of each `ConnectionsInterface`
   method? What would happen if they weren't there?

1. Why are the methods in the two classes derived from `ConnectionsInterface`
   (`CConnMan` and `ConnectionsInterfaceMock`)
   specified with the `override` keyword? (For example,
   [`PushMessage`](https://github.com/dergoegge/bitcoin/blob/f98a4e8d891dd7374ef7dc4c723797bf0705075f/src/net.h#L826))

1. What is the general approach of the
   [`version_handshake`](https://github.com/dergoegge/bitcoin/blob/f98a4e8d891dd7374ef7dc4c723797bf0705075f/src/test/peerman_tests.cpp#L183)
   test? Why does it contain the series of calls to `BOOST_CHECK_EQUAL()`?

1. What is the general approach of the
   [`ping`](https://github.com/dergoegge/bitcoin/blob/f98a4e8d891dd7374ef7dc4c723797bf0705075f/src/test/peerman_tests.cpp#L230)
   test? Why does it mock the current time?



<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
