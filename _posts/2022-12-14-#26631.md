---
layout: pr
date: 2022-12-14
title: "add coverage for dust mempool policy (-dustrelayfee setting)"
pr: 26631
authors: [theStack]
components: ["tests"]
host: larryruane
status: upcoming
commit: 
---

## Notes

### concepts

- Each bitcoin transaction output carries a specific
  [value](https://github.com/bitcoin/bitcoin/blob/6061eb6564105ad54703a7cf3282590d0e1a7f28/src/primitives/transaction.h#L159).
  Bitcoin Core defines _dust_ as an output whose value is less than
  what it would cost to spend this output.

- An important goal of the Bitcoin network is decentralization, so
  there are various development efforts to keep the resource costs
  for running a fully-validating node to a minimum. One way to reduce
  the storage requirement is to keep the size of the UTXO set small.

- It would be inexpensive for an attacker, or a careless wallet, to create
  many tiny-value UTXOs, bloating the UTXO set.
  Whoever is able to spend these UTXOs (and thus remove them
  from the UTXO set) would have little to no incentive to do so.

- For this reason, Bitcoin Core has a policy of not accepting into its
  mempool or relaying any transaction with a spendable _dust_ output, that is, an
  output whose value is below a _dust_ limit.

### details

- When validating an incoming transaction, policy code calculates the
  fee, at a particular feerate, to "pay for" both the output and the (later)
  spending input. This fee is proportional to the sum of the sizes,
  measured in virtual bytes, of both the input and output.

- If the output value is below this (hypothetical)
  fee, it is considered
  [_dust_](https://github.com/bitcoin/bitcoin/blob/1ea02791f3d81c7716d9ea455971203f74d7a107/src/policy/policy.cpp#L65);
  it would cost more to spend this output than its value.

- An output's [virtual
  size](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#transaction-size-calculations)
is just its physical size, but an input typically
  also includes _witness data_ which is discounted: 4 bytes of witness data
  is counted as one byte of virtual data.

- Rather than the dust feerate being hardcoded, `bitcoind` includes a
  configuration option `-dustrelayfee=<feerate>` to set this value.

- This feerate is in units of BTC per kvB (1000 virtual bytes).
  The default is 0.00003 BTC per kvB (3000 sats/kvB or 3 sat/vB).

- More information can be found on
  [stackexchange](https://bitcoin.stackexchange.com/questions/10986/what-is-meant-by-bitcoin-dust).

- There are several kinds of standard outputs (for example, P2PK, P2PKH). Some have
  a characteristic size, both of the output itself and for the input that will
  later spend it. Enforcing the dust limit requires the code to
  [estimate](https://github.com/bitcoin/bitcoin/blob/1ea02791f3d81c7716d9ea455971203f74d7a107/src/policy/policy.cpp#L26)
  the sizes of the various kinds of inputs and outputs.

- The concept of dust was first introduced in
  [PR #2577](https://github.com/bitcoin/bitcoin/pull/2577).
  This [commit](https://github.com/bitcoin/bitcoin/pull/9380/commits/eb30d1a5b215c6dd3763d7f7948f2dd8cb61f6bf)
  from [PR #9380](https://github.com/bitcoin/bitcoin/pull/9380)
  introduced the `-dustrelayfee` option.
  Previous to that PR, the dust feerate was whatever `-minrelaytxfee` was set to.

## Questions

1. Did you review the PR?
   [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. How does the test work? What is its approach?

1. Why is the concept of _dust_ useful? What problems might occur if it didn't exist?

1. A transaction with an output considered "dust" is classified as a _valid_,
   but _non-standard_, transaction.
   What is the difference between valid transaction and a non-standard transaction?
   Would it be better if transactions that don't meet the dust treshhold
   were considered invalid?

1. Why does the dust feerate limit apply to each output individually, rather than
   to all of a transaction's outputs collectively?
   Can you think of an anomolous case in which this policy conflicts with
   being miner-incentive compatatible?

1. Why is this feerate a configuration option, which makes it fairly static
   (most node operators probably just accept the default), rather than having
   it dynamically track the prevailing network feerate?

1. Why is `-dustrelayfee` a _hidden_ (or _debug_) option?

1. Since `-dustrelayfee` is a per-node configuration option, what happens if various
   nodes on the network set different values?

1. Can you see a future scenario where we'd want to change the default value of `-dustrelayfee`?
   Would it more likely be increased or decreased? What does this depend on and which other
   configuration options would then also very likely be adapted?

1. What does the largest possible output script that adheres to standardness rules look like?
   Is it currently implemented in the functional test?

1. Which of the output scripts need to be inferred from an actual public key (derived from ECKey
   in the test)? Could some of them also be created with only random data?

1. The P2TR output script to test is created with `pubkey[1:]`.
   What does this expression do and why is this needed?
   Would that also work with an uncompressed pubkey?
   (Idea: learn about pubkey encoding and the concept of x-only-pubkeys)

1. Can you give an example of an output script that is considered standard and is added
   to the UTXO set (i.e. no null-data), but is still unspendable?
   Bonus: is there a way to create such an output script where this unspendability
   can even be mathematically proven?

 <!-- TODO: After meeting, uncomment and add meeting log between the irc tags
 ## Meeting Log
 
 {% irc %}
 {% endirc %}
 -->
