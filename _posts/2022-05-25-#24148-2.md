---
layout: pr
date: 2022-05-25
title: "Miniscript support in Output Descriptors (part 2)"
pr: 24148
authors: [darosior]
components: ["wallet"]
host: stickies-v
status: upcoming
commit: ec72f35
---

## Notes

- This is a 2-part Review Club. See the notes of the [first part](https://bitcoincore.reviews/24148) for an introduction. If you weren't able to attend, please go through the meeting logs as we won't discuss those Miniscript basic concepts in this second session again.

- In this second part, we'll look at the Miniscript Output Descriptor implementation. We'll focus on the last 9 commits from "miniscript: tiny doc fixups" to "qa: functional test Miniscript watchonly support".

- [Output script descriptors](https://bitcoinops.org/en/topics/output-script-descriptors/) are strings that contain all the information necessary to allow a wallet or other program to track payments made to or spent from a particular script or set of related scripts (i.e. an address or a set of related addresses such as in an HD wallet).

- Descriptors combine well with Miniscript in allowing a wallet to handle tracking and signing for a larger variety of scripts. Since [Bitcoin Core 23.0](https://bitcoincore.org/en/releases/23.0/) descriptor wallets have become the default wallet type.

- This PR [#24148](https://github.com/bitcoin/bitcoin/pull/24148) introduces watch-only support for Miniscript descriptors, extending the [already existing descriptor language](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md). You've probably noticed that both languages have very similar syntax, [this is intentional](https://github.com/bitcoin/bitcoin/pull/16800#issuecomment-583559190).


## Questions
1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. Which function is responsible for parsing the output descriptor strings? How does it determine whether the string represents a `MiniscriptDescriptor`, instead of any other type (including a `WSHDescriptor`)

1. Does `MiniscriptDescriptor` accept Miniscript policy or Miniscript or both?

1. [`Node<Key>::ContainsDuplicateKey`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/miniscript.h#L781) returns a `bool`. What is the return type of `TreeEvalMaybe<std::set<Key>>(upfn)`, and how does it get cast to a `bool`? What does `Key` represent, and why is it templated?

1. Why does [`ScriptMaker`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/descriptor.cpp#L929) use a vector of `CPubKey` and [`StringMaker`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/descriptor.cpp#L949) a vector of `PubkeyProvider` pointers? What's the difference between the two?

1. In [`MiniscriptDescriptor::MakeScripts`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/descriptor.cpp#L979), why do we store a mapping of keys from their IDs in the `FlatSigningProvider provider`?

1. When choosing between two available satisfactions, why should the one that involves less or no signatures be preferred? For example, consider the policy `or(and(older(21), pk(B)), thresh(2, pk(A), pk(B)))` which can always be spent when both A and B sign, and can be spent after 21 blocks when just B signs. After 21 blocks, both satisfactions are available, but why would the satisfaction that involves just B's signature be preferable?

1. In your own words, how does [`Node::TreeEvalMaybe()`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/miniscript.h#L338) work? (Note: there is a [helpful example](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/miniscript.h#L357-L372) further down the method)

1. In [`Node<Key>::FindInsaneSub()`](https://github.com/darosior/bitcoin/blob/ec72f351134bed229baaefc8ffaa1f72688c5435/src/script/miniscript.h#L825), for a given `Node& node` in the tree, what do we expect `Span<const Node*> subs` to be? In practice, in `if (sub) return sub;`, what value would `sub` have in order to `return sub`? (Or: what value would it *not* have?)


<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
