---
layout: pr
date: 2022-09-21
title: "Make stalling timeout adaptive during IBD"
pr: 25880
authors: [mzumsande]
components: ["p2p"]
host: glozow
status: upcoming
commit: 48e5385
---

## Notes

- During Initial Block Download (IBD), after downloading the full headers chain, nodes have a [`BLOCK_DOWNLOAD_WINDOW=1024`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L128)-block window within their best
  chain during which blocks are downloaded in parallel.

    - Blocks still need to be validated sequentially, since their validity depends on all outputs they spend being confirmed in previous blocks.
      When a node receives a block, the node attempts to connect it to the current tip, validate it, and
      calls [`ActivateBestChain()`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/validation.h#L653).

    - The node may have up to [`MAX_BLOCKS_IN_TRANSIT_PER_PEER=16`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L113) in-flight requests to each peer. The
      node will never send more than one request for the same block out at a time.

    - It only uses outbound peers unless that's not possible.

- Peers are not trusted to just always serve correct data in a timely manner. The node tries to
  detect if block download is *stalling* based on the following criteria:

    - The node is unable to connect a new chain of blocks past the current tip, e.g. if the tip is
      at height `i` and blocks `[i+2: i+1024]` have arrived, but block `i+1` hasn't.

    - The node cannot make any more requests; all of the 1024 blocks have already been received or are currently
      being requested.

    - Hint: Try not to confuse the [block download](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L5619-L5641)
      stalling logic with [headers sync](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L5642-L5674)
      timeout logic.

- Once the node detects that it is being stalled, it starts a
  [`stalling_since`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L432)
timer and gives each peer by which it is "bottlenecked" two more seconds to fulfil the block request(s) before
disconnecting them. Then, it connects to a new peer and continues requesting the blocks it needs.

- However, the node will still consider itself to be stalled because the criteria are still met;
  the new peer will be the "bottleneck". On master, this peer is also given only 2 seconds to
fulfil to the block request before disconnection. This is a problem since, if our internet
connection is very slow, we might end up needlessly churning through peers thinking they are
"stalling" us.

## Questions

1. Without looking at the PR, what solutions would you consider? Feel free to be creative.

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. Under what circumstances does a node consider block download to be stalling?

1. What problem is this PR trying to address? How might you be able to observe this issue, and how
   common could it be?

1. If a node has such a slow internet connection that it cannot download blocks in less than 2 seconds, will it be continuously stalled and churning through peers? Why or why not?

1. What approach does this PR take? Is it an appropriate solution?

1. Why use a `std::atomic<std::chrono::seconds>` for `m_block_stalling_timeout`?

<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log
{% irc %}
{% endirc %}
-->
