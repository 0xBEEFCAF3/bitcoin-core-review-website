---
layout: pr
date: 2022-09-21
title: "Make stalling timeout adaptive during IBD"
pr: 25880
authors: [mzumsande]
components: ["p2p"]
host: glozow
status: upcoming
commit: 48e5385
---

## Notes

- During block download, nodes have a `BLOCK_DOWNLOAD_WINDOW=1024`-block window within their best
  chain (this happens after downloading the full headers chain) and download those blocks in
parallel.

    - Blocks still need to be validated sequentially, otherwise some UTXOs might not be available.
      When a block arrives, the node attempts to connect it to the current tip, validate it, and
      [`ActivateBestChain()`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/validation.h#L653).

    - The node may have up to `MAX_BLOCKS_IN_TRANSIT=16` in-flight requests to each peer. The
      node will never send more than one request for the same block out at a time.

    - It only uses outbound peers unless that's not possible.

- Peers are not trusted to just always serve correct data in a timely manner. The node tries to
  detect block download is *stalling* based on the following criteria:

    - The node is unable to connect a new chain of blocks past the current tip, e.g. if the tip is
      at height `i` and blocks `[i+2: i+1024]` have arrived, but block `i+1` hasn't.

    - The node cannot make any more requests; all of the 1024 blocks are either in hand or currently
      being requested.

    - Hint: Try not to confuse the [block download](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L5619-L5641)
      stalling logic with [headers sync](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L5642-L5674)
      timeout logic.

- Once the node detects that it is stalling, it starts a
  [`stalling_since`](https://github.com/bitcoin/bitcoin/blob/a688ff9046a9df58a373086445ab5796cccf9dd3/src/net_processing.cpp#L432)
timer and gives each peer it's "bottlenecked" by 2 seconds to fulfill the block request(s) before
disconnecting them. Then, it connects to a new peer and continues requesting the blocks it needs.

- However, the node will still consider itself to be stalling because the criteria are still met;
  the new peer will be the "bottleneck". On master, this peer is also given only 2 seconds to
respond to the block request before disconnection. This is a problem since, if our internet
connection is very slow, we might end up needlessly churning through peers thinking they are
"stalling" us.

## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?

1. Under what circumstances does a node consider block download to be stalling?

1. What problem is this PR trying to address? How might you be able to observe this issue, and how
   common could it be?

1. If a node has a slow internet connection that is causing everything to take more than 2 seconds
   to download, will it be "stalling" and churning through peers forever? Why or why not?

1. Without looking at the PR, what solutions would you consider? Feel free to be creative.

1. What approach does this PR take? Is it an appropriate solution?

1. Why use a `std::atomic<std::chrono::seconds>` for `m_block_stalling_timeout`?

<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log
{% irc %}
{% endirc %}
-->
